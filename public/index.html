<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Verifiable Claude - Fraud Proofs for LLMs</title>
    <meta name="description" content="Cryptographically verifiable AI responses. Every factual claim is committed to a Merkle tree and deterministically verified against web sources, making AI hallucinations provably detectable.">
    <meta name="keywords" content="AI verification, fraud proofs, Merkle tree, LLM hallucination, verifiable AI, Claude, cryptographic proof">
    <meta name="author" content="Val">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://verifiable-claude.vercel.app/">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Verifiable Claude - Fraud Proofs for LLMs">
    <meta property="og:description" content="Cryptographically verifiable AI responses. Every claim is committed to a Merkle tree and verified against web sources ‚Äî making hallucinations provably detectable.">
    <meta property="og:url" content="https://verifiable-claude.vercel.app/">
    <meta property="og:site_name" content="Verifiable Claude">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Verifiable Claude - Fraud Proofs for LLMs">
    <meta name="twitter:description" content="Cryptographically verifiable AI responses. Every claim is committed to a Merkle tree and verified against web sources ‚Äî making hallucinations provably detectable.">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #0F0F0F;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .line-clamp-3 {
            display: -webkit-box;
            -webkit-line-clamp: 3;
            line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* Hide scrollbar for horizontal scroll areas */
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1E1E1E;
        }

        ::-webkit-scrollbar-thumb {
            background: #404040;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #4D4D4D;
        }
    </style>
</head>
<body class="bg-[#0F0F0F]">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const API_BASE_URL = (window.location.hostname === 'localhost' || window.location.protocol === 'file:') ? 'http://localhost:3001' : '';

        const SUGGESTED_PROMPTS = [
            'who invented fraud proofs',
            'kim jong un\'s daughter - is she the new leader',
            'summarize thinking fast and slow',
            'why did russia invade ukraine',
            'explain the relationship between sleep and alzheimers',
            'why is russia banned from olympics but not the US despite the middle east wars',

        ];

        const sha256Hex = async (str) => {
            const data = new TextEncoder().encode(str);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
        };

        const Shield = () => (
            <svg className="w-6 h-6 text-[#CC785C]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
            </svg>
        );

        const VerifiableClaudeDemo = () => {
            const [prompt, setPrompt] = useState('');
            const [messages, setMessages] = useState([]);
            const [selectedClaim, setSelectedClaim] = useState(null);
            const [verification, setVerification] = useState(null);
            const [loading, setLoading] = useState(false);
            const [verifying, setVerifying] = useState(false);
            const [sidePanelOpen, setSidePanelOpen] = useState(false);
            const [backendStatus, setBackendStatus] = useState({ status: 'checking', mode: null });
            const [fraudProofStages, setFraudProofStages] = useState(null);
            const [currentCommitment, setCurrentCommitment] = useState(null);
            const [merkleModalOpen, setMerkleModalOpen] = useState(false);
            const [merkleProofHashes, setMerkleProofHashes] = useState(null);
            const [whyModalOpen, setWhyModalOpen] = useState(false);
            const [mobileActiveTab, setMobileActiveTab] = useState('chat');
            const messagesEndRef = useRef(null);
            const chatContainerRef = useRef(null);

            const computeMerkleProofPath = async (claimText, proof, committedRoot) => {
                const leafHash = await sha256Hex(claimText);
                let currentHash = leafHash;
                const steps = [];

                for (const proofStep of proof) {
                    const siblingHash = proofStep.hash;
                    const siblingPosition = proofStep.position;
                    const combinedInput = siblingPosition === 'left'
                        ? siblingHash + currentHash
                        : currentHash + siblingHash;
                    const resultHash = await sha256Hex(combinedInput);

                    steps.push({
                        currentHash,
                        siblingHash,
                        siblingPosition,
                        resultHash
                    });
                    currentHash = resultHash;
                }

                return {
                    leafHash,
                    steps,
                    computedRoot: currentHash,
                    committedRoot,
                    matches: currentHash === committedRoot
                };
            };

            useEffect(() => {
                checkBackend();
            }, []);

            useEffect(() => {
                // Scroll to bottom when new messages arrive
                if (messagesEndRef.current) {
                    messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
                }
            }, [messages]);

            const checkBackend = async () => {
                try {
                    const response = await fetch(`${API_BASE_URL}/health?t=${Date.now()}`, {
                        headers: {
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache',
                            'Expires': '0'
                        }
                    });
                    if (response.ok) {
                        const data = await response.json();
                        setBackendStatus({
                            status: 'connected',
                            mode: data.mode || 'unknown',
                            usingOpus: data.usingOpus
                        });
                    } else {
                        setBackendStatus({ status: 'error', mode: null });
                    }
                } catch (err) {
                    setBackendStatus({ status: 'offline', mode: null });
                }
            };

            const callGenerateAPI = async (userPrompt) => {
                const response = await fetch(`${API_BASE_URL}/api/generate?t=${Date.now()}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    },
                    body: JSON.stringify({ prompt: userPrompt })
                });

                if (!response.ok) {
                    throw new Error('Failed to generate response');
                }

                const data = await response.json();

                // Log Merkle commitment if present
                if (data.data.commitment) {
                    console.log('üå≥ Merkle Commitment:', data.data.commitment.root);
                    console.log('   Timestamp:', data.data.commitment.timestamp);
                    console.log('   Claims:', data.data.commitment.claimCount);

                    // Store commitment for fraud proof tracker
                    setCurrentCommitment(data.data.commitment);

                    // Initialize fraud proof stages
                    setFraudProofStages({
                        commitment: {
                            status: 'completed',
                            data: data.data.commitment,
                            timestamp: new Date().toISOString()
                        },
                        challenge: { status: 'pending' },
                        evidenceGathering: { status: 'pending' },
                        deterministicChecks: { status: 'pending' },
                        merkleProofVerification: { status: 'pending' },
                        verdict: { status: 'pending' }
                    });
                }

                return data.data;
            };

            const callVerifyAPI = async (claim, context = {}) => {
                const response = await fetch(`${API_BASE_URL}/api/verify?t=${Date.now()}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    },
                    body: JSON.stringify({ claim, context })
                });

                if (!response.ok) {
                    throw new Error('Failed to verify claim');
                }

                const data = await response.json();
                return data.data;
            };

            const handleSendMessage = async () => {
                if (!prompt.trim() || loading) return;

                const userMessage = {
                    id: Date.now(),
                    role: 'user',
                    content: prompt
                };

                setMessages(prev => [...prev, userMessage]);
                const currentPrompt = prompt;
                setPrompt('');
                setLoading(true);
                setSidePanelOpen(false);
                setSelectedClaim(null);
                setVerification(null);

                try {
                    const result = await callGenerateAPI(currentPrompt);

                    const assistantMessage = {
                        id: Date.now() + 1,
                        role: 'assistant',
                        content: result.text,
                        claims: result.claims,
                        metadata: result.metadata,
                        commitment: result.commitment,
                        userPrompt: currentPrompt
                    };

                    setMessages(prev => [...prev, assistantMessage]);
                } catch (err) {
                    console.error('Generate error:', err);
                    const errorMessage = {
                        id: Date.now() + 1,
                        role: 'error',
                        content: 'Failed to generate response. Make sure backend is running on port 3001.'
                    };
                    setMessages(prev => [...prev, errorMessage]);
                } finally {
                    setLoading(false);
                }
            };

            const handleVerifyClaim = async (claim, userPrompt = '', commitment = null) => {
                setSelectedClaim(claim);
                setSidePanelOpen(true);
                setVerifying(true);
                setVerification(null);

                try {
                    // Stage 1: Commitment (already done)
                    setFraudProofStages(prev => ({
                        ...prev,
                        commitment: {
                            status: 'completed',
                            data: commitment,
                            timestamp: new Date().toISOString()
                        }
                    }));

                    // Stage 2: Challenge initiated
                    setFraudProofStages(prev => ({
                        ...prev,
                        challenge: {
                            status: 'in-progress',
                            data: {
                                claimText: claim.text,
                                claimIndex: claim.merkleIndex,
                                merkleProof: claim.merkleProof
                            },
                            timestamp: new Date().toISOString()
                        }
                    }));

                    await new Promise(resolve => setTimeout(resolve, 500)); // Visual delay

                    setFraudProofStages(prev => ({
                        ...prev,
                        challenge: { ...prev.challenge, status: 'completed' },
                        evidenceGathering: {
                            status: 'in-progress',
                            timestamp: new Date().toISOString()
                        }
                    }));

                    // Include Merkle root in context for fraud proof verification
                    const context = { userPrompt };
                    if (commitment?.root) {
                        context.merkleRoot = commitment.root;
                    }

                    const result = await callVerifyAPI(claim, context);

                    // Stage 3: Evidence gathered
                    setFraudProofStages(prev => ({
                        ...prev,
                        evidenceGathering: {
                            status: 'completed',
                            data: {
                                sourcesFound: result.evidence?.length || 0,
                                searchQuery: userPrompt
                            },
                            timestamp: new Date().toISOString()
                        },
                        deterministicChecks: {
                            status: 'in-progress',
                            timestamp: new Date().toISOString()
                        }
                    }));

                    await new Promise(resolve => setTimeout(resolve, 500));

                    // Stage 4: Deterministic checks
                    if (result.checks) {
                        console.log('üîç Deterministic Checks:');
                        result.checks.forEach(check => {
                            console.log(`  ${check.passed ? '‚úì' : '‚úó'} ${check.name}: ${check.reason}`);
                        });

                        setFraudProofStages(prev => ({
                            ...prev,
                            deterministicChecks: {
                                status: 'completed',
                                data: result.checks,
                                timestamp: new Date().toISOString()
                            },
                            merkleProofVerification: {
                                status: 'in-progress',
                                timestamp: new Date().toISOString()
                            }
                        }));

                        await new Promise(resolve => setTimeout(resolve, 500));
                    }

                    // Stage 5: Merkle proof verification
                    setFraudProofStages(prev => ({
                        ...prev,
                        merkleProofVerification: {
                            status: 'completed',
                            data: {
                                proofValid: result.merkleProofValid !== false,
                                leafHash: claim.text ? claim.text.substring(0, 32) + '...' : ''
                            },
                            timestamp: new Date().toISOString()
                        },
                        verdict: {
                            status: 'in-progress',
                            timestamp: new Date().toISOString()
                        }
                    }));

                    await new Promise(resolve => setTimeout(resolve, 300));

                    // Stage 6: Final verdict
                    setFraudProofStages(prev => ({
                        ...prev,
                        verdict: {
                            status: 'completed',
                            data: {
                                verdict: result.verdict,
                                fraudProof: result.fraudProof
                            },
                            timestamp: new Date().toISOString()
                        }
                    }));

                    setVerification(result);
                } catch (err) {
                    console.error('Verify error:', err);
                    setVerification({
                        verdict: 'ERROR',
                        confidence: 0,
                        reasoning: 'Failed to verify claim. Check your backend logs.',
                        evidence: []
                    });
                    setFraudProofStages(prev => ({
                        ...prev,
                        verdict: {
                            status: 'error',
                            data: { error: err.message },
                            timestamp: new Date().toISOString()
                        }
                    }));
                } finally {
                    setVerifying(false);
                }
            };

            const handleCloseSidePanel = () => {
                setSidePanelOpen(false);
                setSelectedClaim(null);
                setVerification(null);
                setMobileActiveTab('chat');
            };

            const [expandedCheckIndex, setExpandedCheckIndex] = useState(null);

            const getVerdictStyle = (verdict) => {
                if (verdict === 'VERIFIED') return 'text-green-400 bg-green-950/30 border-green-800';
                if (verdict === 'FALSE') return 'text-red-400 bg-red-950/30 border-red-800';
                return 'text-yellow-400 bg-yellow-950/30 border-yellow-800';
            };

            // Component for a fraud proof stage (must be a component to use hooks)
            const FraudProofStage = ({ number, title, stage, details, tooltip }) => {
                const status = stage?.status || 'pending';
                const [showTooltip, setShowTooltip] = useState(false);
                const [tooltipPos, setTooltipPos] = useState({ x: 0, y: 0 });
                const buttonRef = useRef(null);

                const updateTooltipPosition = () => {
                    if (buttonRef.current) {
                        const rect = buttonRef.current.getBoundingClientRect();
                        setTooltipPos({
                            x: rect.right + 8,
                            y: rect.top
                        });
                    }
                };

                const isMobile = () => window.innerWidth < 768;

                const handleMouseEnter = () => {
                    if (isMobile()) return;
                    updateTooltipPosition();
                    setShowTooltip(true);
                };

                const handleMouseLeave = () => {
                    if (isMobile()) return;
                    setShowTooltip(false);
                };

                const handleClick = (e) => {
                    e.stopPropagation();
                    updateTooltipPosition();
                    setShowTooltip(!showTooltip);
                };

                const getStatusIcon = () => {
                    if (status === 'completed') {
                        return <div className="w-6 h-6 rounded-full bg-green-500/20 border-2 border-green-500 flex items-center justify-center">
                            <svg className="w-3 h-3 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M5 13l4 4L19 7" />
                            </svg>
                        </div>;
                    }
                    if (status === 'in-progress') {
                        return <div className="w-6 h-6 rounded-full bg-blue-500/20 border-2 border-blue-500 flex items-center justify-center animate-pulse">
                            <div className="w-2 h-2 bg-blue-400 rounded-full"></div>
                        </div>;
                    }
                    if (status === 'error') {
                        return <div className="w-6 h-6 rounded-full bg-red-500/20 border-2 border-red-500 flex items-center justify-center">
                            <svg className="w-3 h-3 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </div>;
                    }
                    return <div className="w-6 h-6 rounded-full bg-gray-700/30 border-2 border-gray-600 flex items-center justify-center">
                        <div className="text-xs text-gray-600 font-bold">{number}</div>
                    </div>;
                };

                const getStatusColor = () => {
                    if (status === 'completed') return 'text-green-400';
                    if (status === 'in-progress') return 'text-blue-400';
                    if (status === 'error') return 'text-red-400';
                    return 'text-gray-600';
                };

                return (
                    <div className={`relative ${status !== 'pending' ? 'opacity-100' : 'opacity-50'}`}>
                        {/* Connector line */}
                        {number !== '6' && (
                            <div className={`absolute left-3 top-8 w-0.5 h-full ${
                                status === 'completed' ? 'bg-green-500/30' : 'bg-gray-700/30'
                            }`}></div>
                        )}

                        <div className="flex gap-3">
                            {getStatusIcon()}
                            <div className="flex-1 pb-4">
                                <div className={`flex items-center gap-2 font-semibold text-sm ${getStatusColor()}`}>
                                    <span>{title}</span>
                                    {tooltip && (
                                        <>
                                            <button
                                                ref={buttonRef}
                                                className="w-4 h-4 rounded-full border border-gray-500 flex items-center justify-center text-[10px] text-gray-400 hover:bg-gray-700/30 hover:text-gray-300 transition-colors cursor-help"
                                                onMouseEnter={handleMouseEnter}
                                                onMouseLeave={handleMouseLeave}
                                                onClick={handleClick}
                                            >
                                                i
                                            </button>
                                            {showTooltip && ReactDOM.createPortal(
                                                isMobile() ? (
                                                    <div className="fixed inset-0 z-[9999] flex items-center justify-center" onClick={() => setShowTooltip(false)}>
                                                        <div className="absolute inset-0 bg-black/50" />
                                                        <div className="relative z-10 w-72 p-4 bg-[#1A1A1A] border border-[#3D3D3D] rounded-lg shadow-xl" onClick={e => e.stopPropagation()}>
                                                            <button onClick={() => setShowTooltip(false)} className="absolute top-2 right-2 text-gray-400 hover:text-gray-200 p-1">
                                                                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                                                </svg>
                                                            </button>
                                                            <div className="text-xs text-gray-300 leading-relaxed pr-6">{tooltip}</div>
                                                        </div>
                                                    </div>
                                                ) : (
                                                    <div
                                                        className="fixed z-[9999] w-64 p-3 bg-[#1A1A1A] border border-[#3D3D3D] rounded-lg shadow-xl text-xs text-gray-300 leading-relaxed"
                                                        style={{
                                                            left: `${tooltipPos.x}px`,
                                                            top: `${tooltipPos.y}px`
                                                        }}
                                                    >
                                                        {tooltip}
                                                        <div className="absolute left-0 top-2 w-0 h-0 border-t-4 border-t-transparent border-b-4 border-b-transparent border-r-4 border-r-[#3D3D3D] -translate-x-full"></div>
                                                    </div>
                                                ),
                                                document.body
                                            )}
                                        </>
                                    )}
                                </div>
                                {status !== 'pending' && details && (
                                    <div className="mt-2 p-2 bg-[#1A1A1A] rounded border border-[#2D2D2D]">
                                        {details}
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                );
            };

            const MerkleProofModal = ({ claimText, merkleIndex, proofData, commitment, onClose }) => {
                if (!proofData) return null;

                const DownArrow = () => (
                    <div className="flex justify-center py-1.5">
                        <svg className="w-3 h-5 text-gray-600" viewBox="0 0 12 20" fill="none" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 0v16M2 12l4 4 4-4" />
                        </svg>
                    </div>
                );

                return ReactDOM.createPortal(
                    <div className="fixed inset-0 z-[9999] flex items-center justify-center" onClick={onClose}>
                        <div className="absolute inset-0 bg-black/70 backdrop-blur-sm" />
                        <div
                            className="relative z-10 w-full max-w-[560px] mx-4 max-h-[90vh] md:max-h-[85vh] bg-[#1E1E1E] border border-[#3D3D3D] rounded-xl shadow-2xl overflow-hidden flex flex-col"
                            onClick={e => e.stopPropagation()}
                        >
                            {/* Header */}
                            <div className="flex items-center justify-between p-4 border-b border-[#2D2D2D]">
                                <h3 className="text-sm font-bold text-gray-100 flex items-center gap-2">
                                    <span className="text-[#CC785C]">üå≥</span>
                                    Merkle Proof Verification
                                </h3>
                                <button onClick={onClose} className="text-gray-400 hover:text-gray-200 transition">
                                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                    </svg>
                                </button>
                            </div>

                            {/* Scrollable body */}
                            <div className="flex-1 overflow-y-auto p-5">
                                <div className="flex flex-col items-center">

                                    {/* Explainer */}
                                    <div className="w-full mb-4 p-4 bg-[#2D2D2D]/50 border border-[#3D3D3D] rounded-lg text-xs text-gray-400 leading-relaxed space-y-2">
                                        <p><strong className="text-gray-200">What is this?</strong> When the AI generated its response, every factual claim was locked into a cryptographic fingerprint called a Merkle root. This proof walks you through the math that connects this specific claim to that fingerprint.</p>
                                        <p><strong className="text-gray-200">Why it matters:</strong> Once the root is published, the AI cannot change, remove, or deny any claim it made. If a claim turns out to be wrong, this proof ties the error back to the original response ‚Äî it's an unchangeable receipt.</p>
                                        <p><strong className="text-gray-200">How this ensures honesty:</strong> Anyone can re-run this exact computation and get the same result. No trust required ‚Äî just math. If the computed root matches the committed root, the claim was provably part of the original response.</p>
                                    </div>

                                    {/* Committed Root */}
                                    <div className="w-full p-3 bg-[#2D2D2D] border border-[#404040] rounded-lg mb-2">
                                        <div className="text-[10px] text-gray-500 mb-1 font-semibold uppercase tracking-wider">Committed Root</div>
                                        <div className="font-mono text-[11px] text-gray-300 break-all">{proofData.committedRoot}</div>
                                    </div>

                                    {/* Match indicator */}
                                    <div className={`w-full p-2 rounded-lg mb-2 text-center text-xs font-bold ${
                                        proofData.matches
                                            ? 'bg-green-950/30 border border-green-800 text-green-400'
                                            : 'bg-red-950/30 border border-red-800 text-red-400'
                                    }`}>
                                        {proofData.matches ? '‚úì Root matches ‚Äî claim is in the original commitment' : '‚úó Root mismatch ‚Äî proof is invalid!'}
                                    </div>

                                    {/* Computed Root */}
                                    <div className="w-full p-3 bg-[#2D2D2D] border border-[#404040] rounded-lg">
                                        <div className="text-[10px] text-gray-500 mb-1 font-semibold uppercase tracking-wider">Computed Root</div>
                                        <div className="font-mono text-[11px] text-gray-300 break-all">{proofData.computedRoot}</div>
                                    </div>

                                    {/* Proof steps (reversed: root at top, leaf at bottom) */}
                                    {[...proofData.steps].reverse().map((step, i) => {
                                        const stepNum = proofData.steps.length - i;
                                        const leftHash = step.siblingPosition === 'left' ? step.siblingHash : step.currentHash;
                                        const rightHash = step.siblingPosition === 'right' ? step.siblingHash : step.currentHash;
                                        const leftLabel = step.siblingPosition === 'left' ? 'Sibling' : 'Current';
                                        const rightLabel = step.siblingPosition === 'right' ? 'Sibling' : 'Current';
                                        const leftStyle = step.siblingPosition === 'left'
                                            ? 'bg-blue-950/20 border-blue-800/30'
                                            : 'bg-[#CC785C]/10 border-[#CC785C]/30';
                                        const rightStyle = step.siblingPosition === 'right'
                                            ? 'bg-blue-950/20 border-blue-800/30'
                                            : 'bg-[#CC785C]/10 border-[#CC785C]/30';

                                        return (
                                            <div key={i} className="w-full">
                                                <DownArrow />
                                                <div className="p-3 bg-[#1A1A1A] border border-[#2D2D2D] rounded-lg">
                                                    <div className="text-[10px] text-[#CC785C] font-semibold mb-2 uppercase tracking-wider">
                                                        Step {stepNum}
                                                    </div>
                                                    <div className="flex gap-2 mb-2">
                                                        <div className={`flex-1 p-2 rounded border ${leftStyle}`}>
                                                            <div className="text-[9px] text-gray-500 mb-1">{leftLabel}</div>
                                                            <div className="font-mono text-[10px] text-gray-400 break-all">{leftHash}</div>
                                                        </div>
                                                        <div className="flex items-center text-gray-600 text-xs font-bold">+</div>
                                                        <div className={`flex-1 p-2 rounded border ${rightStyle}`}>
                                                            <div className="text-[9px] text-gray-500 mb-1">{rightLabel}</div>
                                                            <div className="font-mono text-[10px] text-gray-400 break-all">{rightHash}</div>
                                                        </div>
                                                    </div>
                                                    <div className="flex justify-center py-1 text-gray-600 text-[10px]">SHA-256 ‚Üì</div>
                                                    <div className="p-2 bg-[#2D2D2D] rounded border border-[#404040]">
                                                        <div className="text-[9px] text-gray-500 mb-1">Result</div>
                                                        <div className="font-mono text-[10px] text-gray-300 break-all">{step.resultHash}</div>
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })}

                                    {/* Arrow to leaf */}
                                    <DownArrow />

                                    {/* Leaf hash */}
                                    <div className="w-full p-3 bg-[#CC785C]/10 border border-[#CC785C]/30 rounded-lg">
                                        <div className="text-[10px] text-[#CC785C] font-semibold mb-1 uppercase tracking-wider">
                                            Leaf Hash (Claim #{merkleIndex})
                                        </div>
                                        <div className="font-mono text-[11px] text-gray-300 break-all">{proofData.leafHash}</div>
                                    </div>

                                    {/* Arrow to claim */}
                                    <DownArrow />

                                    {/* Claim text */}
                                    <div className="w-full p-3 bg-[#2D2D2D] border border-[#404040] rounded-lg">
                                        <div className="text-[10px] text-gray-500 mb-1 font-semibold uppercase tracking-wider">Original Claim</div>
                                        <div className="text-sm text-gray-100">"{claimText}"</div>
                                    </div>

                                </div>
                            </div>

                            {/* Footer */}
                            <div className="p-3 border-t border-[#2D2D2D] bg-[#1A1A1A]">
                                <div className="text-[10px] text-gray-500 flex justify-between">
                                    <span>Committed: {new Date(commitment.timestamp).toLocaleString()}</span>
                                    <span>Claims in tree: {commitment.claimCount}</span>
                                </div>
                            </div>
                        </div>
                    </div>,
                    document.body
                );
            };

            const renderMessageContent = (message) => {
                const text = message.content;
                const claims = message.claims || [];
                const userPrompt = message.userPrompt || '';
                const commitment = message.commitment || null;

                // Debug: log claims to console
                if (claims.length > 0) {
                    console.log('Message claims:', claims.map(c => c.text));
                }

                // Create a map of claim texts for quick lookup
                const claimTexts = new Set(claims.map(c => c.text.toLowerCase().trim()));

                const renderLine = (line, lineIndex) => {
                    // Headers (## Header)
                    if (line.startsWith('## ')) {
                        return <h3 key={lineIndex} className="text-lg font-bold text-gray-100 mt-4 mb-2">{line.substring(3)}</h3>;
                    }

                    // List items (- Item or ‚Ä¢ Item)
                    if (line.trim().startsWith('- ')) {
                        const content = line.trim().substring(2);
                        return (
                            <div key={lineIndex} className="ml-4 text-gray-300 mb-1">
                                ‚Ä¢ {renderTextWithClaims(content, claims, userPrompt, commitment)}
                            </div>
                        );
                    }

                    if (line.trim().startsWith('‚Ä¢ ')) {
                        const content = line.trim().substring(2);
                        return (
                            <div key={lineIndex} className="ml-4 text-gray-300 mb-1">
                                ‚Ä¢ {renderTextWithClaims(content, claims, userPrompt, commitment)}
                            </div>
                        );
                    }

                    // Regular text
                    if (line.trim()) {
                        return (
                            <div key={lineIndex} className="text-gray-300 mb-2 leading-relaxed">
                                {renderTextWithClaims(line, claims, userPrompt, commitment)}
                            </div>
                        );
                    }

                    // Empty line
                    return <div key={lineIndex} className="h-2"></div>;
                };

                return text.split('\n').map(renderLine);
            };

            const renderTextWithClaims = (text, claims, userPrompt = '', commitment = null) => {
                // 1. Strip ** markers from text, track which ranges in plain text are bold
                const stripBoldMarkers = (raw) => {
                    let plain = '';
                    const boldRanges = [];
                    let i = 0;
                    while (i < raw.length) {
                        if (i + 1 < raw.length && raw[i] === '*' && raw[i + 1] === '*') {
                            const close = raw.indexOf('**', i + 2);
                            if (close !== -1) {
                                boldRanges.push({ start: plain.length, end: plain.length + (close - i - 2) });
                                plain += raw.substring(i + 2, close);
                                i = close + 2;
                                continue;
                            }
                        }
                        plain += raw[i];
                        i++;
                    }
                    return { plain, boldRanges };
                };

                const { plain, boldRanges } = stripBoldMarkers(text);

                // 2. Do claim matching on plain text (no ** markers to interfere)
                // Priority: 3=exact, 2=punctuation-stripped, 1=fuzzy
                const matches = [];
                if (claims && claims.length > 0) {
                    const lowerPlain = plain.toLowerCase();
                    claims.forEach(claim => {
                        const claimText = claim.text;
                        const lowerClaim = claimText.toLowerCase();

                        let index = lowerPlain.indexOf(lowerClaim);
                        if (index !== -1) {
                            matches.push({ start: index, end: index + claimText.length, claim, priority: 3 });
                        } else {
                            const claimNoPunct = claimText.replace(/[.,;:!?]+$/, '');
                            index = lowerPlain.indexOf(claimNoPunct.toLowerCase());
                            if (index !== -1) {
                                matches.push({ start: index, end: index + claimNoPunct.length, claim, priority: 2 });
                            } else {
                                const significantWords = claimText.toLowerCase()
                                    .replace(/[.,;:!?()]/g, '')
                                    .split(/\s+/)
                                    .filter(word => word.length > 2 && !['the', 'and', 'was', 'were', 'that', 'this', 'from', 'with', 'for'].includes(word));

                                const matchCount = significantWords.filter(word => lowerPlain.includes(word)).length;
                                const threshold = significantWords.length <= 2 ? 1 : Math.ceil(significantWords.length * 0.5);
                                if (matchCount >= threshold && significantWords.length > 0) {
                                    let matchStart = -1, matchEnd = -1;
                                    significantWords.forEach(word => {
                                        const wordIndex = lowerPlain.indexOf(word);
                                        if (wordIndex !== -1) {
                                            if (matchStart === -1 || wordIndex < matchStart) matchStart = wordIndex;
                                            const wordEnd = wordIndex + word.length;
                                            if (matchEnd === -1 || wordEnd > matchEnd) matchEnd = wordEnd;
                                        }
                                    });
                                    if (matchStart !== -1 && matchEnd !== -1 && matchEnd > matchStart) {
                                        while (matchStart > 0 && /\w/.test(plain[matchStart - 1])) matchStart--;
                                        while (matchEnd < plain.length && /\w/.test(plain[matchEnd])) matchEnd++;
                                        matches.push({ start: matchStart, end: matchEnd, claim, priority: 1 });
                                    }
                                }
                            }
                        }
                    });
                }

                // Sort by priority (highest first), then by position
                // This ensures exact matches claim positions before fuzzy matches
                matches.sort((a, b) => b.priority - a.priority || a.start - b.start);
                const claimRanges = [];
                const usedPositions = new Set();
                matches.forEach(match => {
                    let hasOverlap = false;
                    for (let i = match.start; i < match.end; i++) {
                        if (usedPositions.has(i)) { hasOverlap = true; break; }
                    }
                    if (!hasOverlap) {
                        claimRanges.push(match);
                        for (let i = match.start; i < match.end; i++) usedPositions.add(i);
                    }
                });
                // Re-sort by position for rendering
                claimRanges.sort((a, b) => a.start - b.start);

                // 3. Build segments by merging bold ranges and claim ranges
                const boundaries = new Set([0, plain.length]);
                boldRanges.forEach(r => { boundaries.add(r.start); boundaries.add(r.end); });
                claimRanges.forEach(m => { boundaries.add(m.start); boundaries.add(m.end); });
                const sorted = [...boundaries].sort((a, b) => a - b);

                const result = [];
                for (let i = 0; i < sorted.length - 1; i++) {
                    const segStart = sorted[i];
                    const segEnd = sorted[i + 1];
                    if (segStart === segEnd) continue;

                    const segText = plain.substring(segStart, segEnd);
                    const segIsBold = boldRanges.some(r => segStart >= r.start && segEnd <= r.end);
                    const segClaim = claimRanges.find(m => segStart >= m.start && segEnd <= m.end);

                    let content = segIsBold
                        ? <strong className="font-semibold text-gray-100">{segText}</strong>
                        : segText;

                    if (segClaim) {
                        result.push(
                            <span
                                key={`seg-${i}`}
                                onClick={() => handleVerifyClaim(segClaim.claim, userPrompt)}
                                className="cursor-pointer hover:bg-[#CC785C]/20 hover:text-[#CC785C] transition-colors rounded px-1 py-1 border-b border-[#CC785C]/40 border-dotted"
                                title="Click to verify this claim"
                            >
                                {content}
                            </span>
                        );
                    } else {
                        result.push(<span key={`seg-${i}`}>{content}</span>);
                    }
                }

                return result;
            };

            return (
                <div className="h-screen bg-[#0F0F0F] flex flex-col overflow-hidden">
                    {/* Header */}
                    <div className="px-3 py-2 md:px-6 md:py-3">
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <Shield />
                                <h1 className="text-xl font-bold bg-gradient-to-r from-[#CC785C] to-[#D97757] bg-clip-text text-transparent">
                                    Verifiable Claude
                                </h1>
                            </div>
                            <div className="text-xs">
                                {backendStatus.status === 'checking' && (
                                    <span className="text-gray-400">‚óè Checking...</span>
                                )}
                                {backendStatus.status === 'connected' && backendStatus.mode === 'sonnet' && (
                                    <span className="text-green-400">‚óè Using Sonnet</span>
                                )}
                                {backendStatus.status === 'connected' && backendStatus.mode === 'opus' && (
                                    <span className="text-green-400">‚óè Using Opus</span>
                                )}
                                {backendStatus.status === 'connected' && backendStatus.mode === 'test' && (
                                    <span className="text-yellow-400">‚óè Using Test Data</span>
                                )}
                                {backendStatus.status === 'connected' && backendStatus.mode && backendStatus.mode !== 'sonnet' && backendStatus.mode !== 'opus' && backendStatus.mode !== 'test' && (
                                    <span className="text-green-400">‚óè Using {backendStatus.mode.charAt(0).toUpperCase() + backendStatus.mode.slice(1)}</span>
                                )}
                                {backendStatus.status === 'connected' && !backendStatus.mode && (
                                    <span className="text-green-400">‚óè Connected</span>
                                )}
                                {backendStatus.status === 'offline' && (
                                    <span className="text-red-400">‚óè Offline</span>
                                )}
                                {backendStatus.status === 'error' && (
                                    <span className="text-red-400">‚óè Error</span>
                                )}
                            </div>
                        </div>
                    </div>

                    {/* Main content area with chat and side panel */}
                    <div className="flex-1 flex overflow-hidden">
                        {/* Left Sidebar - Fraud Proof Tracker */}
                        <div className={`${mobileActiveTab === 'fraud' ? 'fixed top-[44px] left-0 right-0 bottom-0 z-40 flex flex-col' : 'hidden'} md:relative md:top-auto md:left-auto md:right-auto md:bottom-auto md:flex md:w-80 md:flex-col transition-all duration-300 ${fraudProofStages ? 'opacity-100' : 'opacity-50'} backdrop-blur-xl bg-[#0F0F0F] md:bg-black/10`} style={{backdropFilter: 'blur(24px)', WebkitBackdropFilter: 'blur(24px)'}}>
                            <div className="p-4 border-b border-[#2D2D2D] sticky top-0 bg-[#0F0F0F] md:bg-black/10 backdrop-blur-md z-10">
                                <h2 className="text-sm font-bold text-white flex items-center gap-2">
                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" />
                                    </svg>
                                    FRAUD PROOF TRACKER
                                </h2>
                                <p className="text-xs text-gray-500 mt-1">Optimistic verification with cryptographic proofs</p>
                            </div>

                            <div className="flex-1 overflow-y-auto">
                            <div className="p-4 space-y-4">
                                {fraudProofStages ? (
                                    <>
                                        {/* Stage 1: Commitment */}
                                        <FraudProofStage
                                            number='1'
                                            title='Commitment Phase'
                                            stage={fraudProofStages.commitment}
                                            details={fraudProofStages.commitment?.status === 'completed' && fraudProofStages.commitment.data && (
                                                <div className="text-xs space-y-1">
                                                    <div className="font-mono text-gray-400">
                                                        Root: {fraudProofStages.commitment.data.root?.substring(0, 16)}...
                                                    </div>
                                                    <div className="text-gray-500">
                                                        Claims: {fraudProofStages.commitment.data.claimCount}
                                                    </div>
                                                    <div className="text-gray-600 text-[10px]">
                                                        {new Date(fraudProofStages.commitment.data.timestamp).toLocaleTimeString()}
                                                    </div>
                                                </div>
                                            )}
                                            tooltip="The AI locks in all its claims with a cryptographic 'fingerprint' (Merkle root). Like signing a contract - it can't change what it said later."
                                        />

                                        {/* Stage 2: Challenge */}
                                        <FraudProofStage
                                            number='2'
                                            title='Challenge Initiated'
                                            stage={fraudProofStages.challenge}
                                            details={fraudProofStages.challenge?.status !== 'pending' && fraudProofStages.challenge?.data && (
                                                <div className="text-xs space-y-1">
                                                    <div className="text-gray-400">
                                                        "{fraudProofStages.challenge.data.claimText?.substring(0, 40)}..."
                                                    </div>
                                                    <div className="text-gray-500">
                                                        Claim #{fraudProofStages.challenge.data.claimIndex}
                                                    </div>
                                                    {fraudProofStages.challenge.data.merkleProof && (
                                                        <div className="text-gray-600">
                                                            Proof steps: {fraudProofStages.challenge.data.merkleProof.length}
                                                        </div>
                                                    )}
                                                </div>
                                            )}
                                            tooltip="You picked a specific claim to verify. The system pulls up the cryptographic 'receipt' (Merkle proof) showing this claim was in the original response."
                                        />

                                        {/* Stage 3: Evidence Gathering */}
                                        <FraudProofStage
                                            number='3'
                                            title='Evidence Gathering'
                                            stage={fraudProofStages.evidenceGathering}
                                            details={fraudProofStages.evidenceGathering?.status === 'completed' && fraudProofStages.evidenceGathering?.data && (
                                                <div className="text-xs space-y-1">
                                                    <div className="text-gray-400">
                                                        Sources found: {fraudProofStages.evidenceGathering.data.sourcesFound}
                                                    </div>
                                                    <div className="text-gray-500 truncate">
                                                        Query: {fraudProofStages.evidenceGathering.data.searchQuery}
                                                    </div>
                                                </div>
                                            )}
                                            tooltip="The system searches the web for sources that could verify or disprove the claim. Think of it like fact-checking with Google."
                                        />

                                        {/* Stage 4: Deterministic Checks */}
                                        <FraudProofStage
                                            number='4'
                                            title='Deterministic Verification'
                                            stage={fraudProofStages.deterministicChecks}
                                            details={fraudProofStages.deterministicChecks?.status === 'completed' && fraudProofStages.deterministicChecks?.data && (
                                                <div className="text-xs space-y-1">
                                                    {fraudProofStages.deterministicChecks.data.map((check, i) => (
                                                        <div key={i} className={`flex items-start gap-2 ${check.notApplicable ? 'text-gray-400' : check.passed ? 'text-green-400' : 'text-red-400'}`}>
                                                            <span>{check.notApplicable ? '‚óã' : check.passed ? '‚úì' : '‚úó'}</span>
                                                            <div className="flex-1">
                                                                <div className="font-medium">{check.name}</div>
                                                                <div className="text-gray-500 text-[10px]">{check.reason}</div>
                                                            </div>
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                            tooltip="Runs 5 automated checks on the evidence - like a checklist. Same inputs always give the same results. No AI judgment, just rules."
                                        />

                                        {/* Stage 5: Merkle Proof Verification */}
                                        <FraudProofStage
                                            number='5'
                                            title='Merkle Proof Verification'
                                            stage={fraudProofStages.merkleProofVerification}
                                            details={fraudProofStages.merkleProofVerification?.status === 'completed' && fraudProofStages.merkleProofVerification?.data && (
                                                <div className="text-xs space-y-1">
                                                    <div className={fraudProofStages.merkleProofVerification.data.proofValid ? 'text-green-400' : 'text-red-400'}>
                                                        {fraudProofStages.merkleProofVerification.data.proofValid ? '‚úì Proof Valid' : '‚úó Proof Invalid'}
                                                    </div>
                                                    <div className="text-gray-500 text-[10px] font-mono">
                                                        Claim committed in original response
                                                    </div>
                                                </div>
                                            )}
                                            tooltip="Mathematically proves the claim was actually in the AI's original response. Like checking if a page is really in a book using cryptography."
                                        />

                                        {/* Stage 6: Verdict */}
                                        <FraudProofStage
                                            number='6'
                                            title='Final Verdict'
                                            stage={fraudProofStages.verdict}
                                            details={fraudProofStages.verdict?.status === 'completed' && fraudProofStages.verdict?.data && (
                                                <div className="text-xs space-y-1">
                                                    <div className={`font-bold ${
                                                        fraudProofStages.verdict.data.verdict === 'VERIFIED' ? 'text-green-400' :
                                                        fraudProofStages.verdict.data.verdict === 'FRAUD_PROVEN' ? 'text-red-400' :
                                                        'text-yellow-400'
                                                    }`}>
                                                        {fraudProofStages.verdict.data.verdict}
                                                    </div>
                                                    {fraudProofStages.verdict.data.fraudProof && (
                                                        <div className="text-red-400 text-[10px] p-2 bg-red-950/20 rounded border border-red-900/30">
                                                            üö® Fraud Detected: {fraudProofStages.verdict.data.fraudProof.reason}
                                                        </div>
                                                    )}
                                                </div>
                                            )}
                                            tooltip="Based on all the checks, determines if the claim is verified, uncertain, or proven false. If fraud is detected, anyone can independently verify this proof."
                                        />
                                    </>
                                ) : (
                                    <div className="text-center text-gray-600 py-8 text-sm">
                                        <div className="mb-2">‚è≥</div>
                                        <div>Awaiting response...</div>
                                        <div className="text-xs mt-2">Fraud proof tracker will activate once a response is generated</div>
                                    </div>
                                )}
                            </div>

                            {/* Footer */}
                            {currentCommitment && (
                                <div className="p-4 border-t border-[#2D2D2D] mt-4">
                                    <div className="text-[10px] text-gray-600 space-y-1">
                                        <div className="font-semibold text-gray-500">Current Commitment:</div>
                                        <div className="font-mono break-all">{currentCommitment.root}</div>
                                        <div>{new Date(currentCommitment.timestamp).toLocaleString()}</div>
                                    </div>
                                </div>
                            )}
                            </div>

                            {/* Bottom button */}
                            <div className="p-3 pb-20 md:pb-3 border-t border-[#2D2D2D]">
                                <button
                                    onClick={() => setWhyModalOpen(true)}
                                    className="w-full px-3 py-3 md:py-2 text-xs text-[#CC785C] bg-[#CC785C]/10 border border-[#CC785C]/30 rounded-lg hover:bg-[#CC785C]/20 transition-colors"
                                >
                                    Why I built this
                                </button>
                            </div>
                        </div>

                        {/* Chat area */}
                        <div className={`flex-1 flex flex-col transition-all duration-300 ${sidePanelOpen ? 'md:pr-96' : ''} ${mobileActiveTab === 'fraud' ? 'hidden md:flex' : ''}`}>
                            {/* Messages */}
                            <div ref={chatContainerRef} className="flex-1 overflow-y-auto px-3 py-4 md:px-6">
                                {messages.length === 0 ? (
                                    <div className="h-full flex items-center justify-center">
                                        <div className="text-center max-w-full px-4 md:max-w-2xl md:px-0">
                                            <div className="mb-6">
                                                <div className="inline-block p-4 bg-[#1E1E1E] rounded-full border border-[#3D3D3D] mb-4">
                                                    <Shield />
                                                </div>
                                            </div>
                                            <h2 className="text-2xl font-bold text-gray-100 mb-2">Fraud Proofs for LLM Outputs</h2>
                                            <p className="text-gray-400 mb-6">
                                                Ask questions and verify claims against external sources.
                                                Hover over verifiable sentences to check them.
                                            </p>
                                        </div>
                                    </div>
                                ) : (
                                    <div className="max-w-full md:max-w-2xl mx-auto space-y-6">
                                        {messages.map(message => (
                                            <div key={message.id} className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                                                {message.role === 'user' ? (
                                                    <div className="bg-[#CC785C] text-white rounded-2xl px-4 py-3 max-w-[85%] md:max-w-xl">
                                                        {message.content}
                                                    </div>
                                                ) : message.role === 'error' ? (
                                                    <div className="bg-red-950/30 border border-red-800 text-red-400 rounded-2xl px-4 py-3 max-w-[85%] md:max-w-xl">
                                                        {message.content}
                                                    </div>
                                                ) : (
                                                    <div className="bg-[#1E1E1E] border border-[#3D3D3D] rounded-2xl px-5 py-4 w-full">
                                                        <div className="prose prose-invert max-w-none">
                                                            {renderMessageContent(message)}
                                                        </div>
                                                        {message.claims && message.claims.length > 0 && (
                                                            <div className="mt-4 pt-3 border-t border-[#3D3D3D] text-xs text-gray-400">
                                                                {message.claims.length} verifiable claim{message.claims.length !== 1 ? 's' : ''} ‚Ä¢ Click underlined text to verify
                                                            </div>
                                                        )}
                                                    </div>
                                                )}
                                            </div>
                                        ))}
                                        {loading && (
                                            <div className="flex justify-start">
                                                <div className="bg-[#1E1E1E] border border-[#3D3D3D] rounded-2xl px-5 py-4">
                                                    <div className="flex items-center gap-2">
                                                        <div className="w-2 h-2 bg-[#CC785C] rounded-full animate-bounce" style={{animationDelay: '0ms'}}></div>
                                                        <div className="w-2 h-2 bg-[#CC785C] rounded-full animate-bounce" style={{animationDelay: '150ms'}}></div>
                                                        <div className="w-2 h-2 bg-[#CC785C] rounded-full animate-bounce" style={{animationDelay: '300ms'}}></div>
                                                    </div>
                                                </div>
                                            </div>
                                        )}
                                        <div ref={messagesEndRef} />
                                    </div>
                                )}
                            </div>

                            {/* Input area */}
                            <div className="bg-[#0F0F0F] p-3 pb-4 mb-16 md:mb-0 md:p-6 md:pb-6">
                                <div className="max-w-full md:max-w-2xl mx-auto">
                                    {/* Suggested prompts */}
                                    {messages.length === 0 && (
                                        <div className="mb-4 flex flex-col gap-2 md:flex-row md:flex-wrap md:justify-center">
                                            {SUGGESTED_PROMPTS.map(suggestion => (
                                                <button
                                                    key={suggestion}
                                                    onClick={async () => {
                                                        if (loading || backendStatus.status !== 'connected') return;

                                                        const userMessage = {
                                                            id: Date.now(),
                                                            role: 'user',
                                                            content: suggestion
                                                        };

                                                        setMessages(prev => [...prev, userMessage]);
                                                        setPrompt('');
                                                        setLoading(true);
                                                        setSidePanelOpen(false);
                                                        setSelectedClaim(null);
                                                        setVerification(null);

                                                        try {
                                                            const result = await callGenerateAPI(suggestion);

                                                            const assistantMessage = {
                                                                id: Date.now() + 1,
                                                                role: 'assistant',
                                                                content: result.text,
                                                                claims: result.claims,
                                                                metadata: result.metadata,
                                                                commitment: result.commitment,
                                                                userPrompt: suggestion
                                                            };

                                                            setMessages(prev => [...prev, assistantMessage]);
                                                        } catch (err) {
                                                            console.error('Generate error:', err);
                                                            const errorMessage = {
                                                                id: Date.now() + 1,
                                                                role: 'error',
                                                                content: 'Failed to generate response. Make sure backend is running on port 3001.'
                                                            };
                                                            setMessages(prev => [...prev, errorMessage]);
                                                        } finally {
                                                            setLoading(false);
                                                        }
                                                    }}
                                                    className="text-sm px-3 py-2.5 md:py-1.5 bg-[#2D2D2D] hover:bg-[#3D3D3D] text-gray-300 border border-[#404040] rounded-lg transition text-left"
                                                    disabled={loading || backendStatus.status !== 'connected'}
                                                >
                                                    {suggestion}
                                                </button>
                                            ))}
                                        </div>
                                    )}

                                    {/* Input container */}
                                    <div className="bg-[#2D2D2D] border border-[#404040] rounded-3xl px-4 py-2 flex items-center gap-2 shadow-lg hover:border-[#4D4D4D] transition-colors">
                                        <input
                                            type="text"
                                            value={prompt}
                                            onChange={(e) => setPrompt(e.target.value)}
                                            onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}
                                            placeholder="Ask anything and get verifiable facts"
                                            className="flex-1 bg-transparent text-gray-100 placeholder-gray-500 outline-none py-2 min-h-[44px] md:min-h-0"
                                            disabled={backendStatus.status !== 'connected' || loading}
                                            autoFocus
                                        />
                                        <button
                                            onClick={handleSendMessage}
                                            disabled={loading || !prompt.trim() || backendStatus.status !== 'connected'}
                                            className="p-2 bg-[#CC785C] text-white rounded-full hover:bg-[#D97757] disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                                            title="Send message"
                                        >
                                            <svg className="w-5 h-5 rotate-90" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                                            </svg>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* Side panel for verification */}
                        <div className={`fixed right-0 top-[44px] bottom-0 w-full bg-[#0F0F0F] z-[60] md:top-[52px] md:w-96 md:bg-black/10 md:z-auto md:rounded-tl-2xl transform transition-transform duration-300 ${sidePanelOpen ? 'translate-x-0' : 'translate-x-full'} overflow-y-auto overflow-x-hidden backdrop-blur-xl`} style={{backdropFilter: 'blur(24px)', WebkitBackdropFilter: 'blur(24px)'}}>
                            <div className="p-4 flex items-center justify-between sticky top-0 bg-[#0F0F0F] md:bg-black/10 backdrop-blur-md z-10">
                                <h2 className="font-bold text-gray-100">üõ°Ô∏è Verification</h2>
                                <button
                                    onClick={handleCloseSidePanel}
                                    className="text-gray-400 hover:text-gray-200 transition p-2 -mr-2"
                                >
                                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                    </svg>
                                </button>
                            </div>

                            {selectedClaim && (
                                <div className="p-4 pb-20 md:pb-4 min-w-0">
                                    <div className="mb-4 p-3 bg-[#2D2D2D] border border-[#404040] rounded-lg">
                                        <div className="text-xs text-gray-400 mb-1">Claim:</div>
                                        <div className="text-sm text-gray-100">{selectedClaim.text}</div>
                                    </div>

                                    {selectedClaim.merkleProof && selectedClaim.merkleProof.length > 0 && currentCommitment && (
                                        <button
                                            onClick={async () => {
                                                const result = await computeMerkleProofPath(
                                                    selectedClaim.text,
                                                    selectedClaim.merkleProof,
                                                    currentCommitment.root
                                                );
                                                setMerkleProofHashes(result);
                                                setMerkleModalOpen(true);
                                            }}
                                            className="mb-4 w-full flex items-center justify-center gap-2 px-3 py-2 text-xs text-[#CC785C] bg-[#CC785C]/10 border border-[#CC785C]/30 rounded-lg hover:bg-[#CC785C]/20 transition-colors"
                                        >
                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 5a1 1 0 011-1h14a1 1 0 011 1v2a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM4 13a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H5a1 1 0 01-1-1v-6zM16 13a1 1 0 011-1h2a1 1 0 011 1v6a1 1 0 01-1 1h-2a1 1 0 01-1-1v-6z" />
                                            </svg>
                                            See Merkle proof verification
                                        </button>
                                    )}

                                    {verifying ? (
                                        <div className="text-center py-8">
                                            <div className="animate-spin w-10 h-10 border-4 border-[#CC785C] border-t-transparent rounded-full mx-auto mb-3" />
                                            <div className="text-sm font-medium text-gray-100">Verifying...</div>
                                            <div className="text-xs text-gray-400 mt-2">
                                                Searching external sources
                                            </div>
                                        </div>
                                    ) : verification && (
                                        <>
                                            <div className={`mb-4 p-3 rounded-lg border-2 ${getVerdictStyle(verification.verdict)}`}>
                                                <div className="flex items-center gap-2 mb-1">
                                                    <span className="font-bold">{verification.verdict}</span>
                                                    {verification.confidence !== undefined && (
                                                        <span className="text-xs">({verification.confidence}%)</span>
                                                    )}
                                                </div>
                                                {verification.reasoning && (
                                                    <div className="text-xs mt-2">{verification.reasoning}</div>
                                                )}
                                            </div>

                                            {verification.checks?.length > 0 && (
                                                <div className="mb-4">
                                                    <h3 className="text-sm font-semibold mb-3 text-gray-200">
                                                        Deterministic Checks:
                                                    </h3>
                                                    <div className="space-y-2">
                                                        {verification.checks.map((check, i) => (
                                                            <div key={i} className={`p-3 rounded-lg border ${
                                                                check.notApplicable ? 'bg-gray-900/20 border-gray-600/30' :
                                                                check.passed ? 'bg-green-950/20 border-green-800/30' : 'bg-red-950/20 border-red-800/30'
                                                            }`}>
                                                                <div className="flex items-start gap-2">
                                                                    <span className={`text-sm ${
                                                                        check.notApplicable ? 'text-gray-400' :
                                                                        check.passed ? 'text-green-400' : 'text-red-400'
                                                                    }`}>
                                                                        {check.notApplicable ? '‚óã' : check.passed ? '‚úì' : '‚úó'}
                                                                    </span>
                                                                    <div className="flex-1">
                                                                        <div className="flex items-center justify-between">
                                                                            <div className={`font-medium text-sm ${
                                                                                check.notApplicable ? 'text-gray-400' :
                                                                                check.passed ? 'text-green-400' : 'text-red-400'
                                                                            }`}>
                                                                                {check.name}
                                                                                {check.notApplicable && <span className="ml-2 text-[10px] text-gray-500">N/A</span>}
                                                                            </div>
                                                                            <button
                                                                                onClick={() => setExpandedCheckIndex(expandedCheckIndex === i ? null : i)}
                                                                                className={`text-[10px] px-2 py-1 rounded border transition-colors ${
                                                                                    check.notApplicable
                                                                                        ? 'bg-gray-800/40 hover:bg-gray-800/60 text-gray-400 border-gray-700/50' :
                                                                                    check.passed
                                                                                        ? 'bg-gray-800/40 hover:bg-gray-800/60 text-gray-300 border-gray-700/50'
                                                                                        : 'bg-red-900/40 hover:bg-red-900/60 text-red-300 border-red-800/50'
                                                                                }`}
                                                                            >
                                                                                {expandedCheckIndex === i ? 'Hide Details' : 'See Details'}
                                                                            </button>
                                                                        </div>
                                                                        <div className={`text-xs mt-1 ${check.notApplicable ? 'text-gray-400' : 'text-gray-300'}`}>{check.reason}</div>

                                                                        {/* Expanded details for all checks */}
                                                                        {expandedCheckIndex === i && (
                                                                            <div className={`mt-3 p-3 bg-black/30 rounded border overflow-hidden ${
                                                                                check.notApplicable ? 'border-gray-600/30' :
                                                                                check.passed ? 'border-green-900/30' : 'border-red-900/30'
                                                                            }`}>
                                                                                <div className={`text-xs font-semibold mb-2 ${
                                                                                    check.notApplicable ? 'text-gray-400' :
                                                                                    check.passed ? 'text-green-300' : 'text-red-300'
                                                                                }`}>
                                                                                    {check.notApplicable ? 'Check Details:' : check.passed ? 'Check Details:' : 'Failure Details:'}
                                                                                </div>
                                                                                <div className="space-y-2 text-[11px] overflow-hidden">
                                                                                    {check.name === 'URL Validity' && (
                                                                                        <>
                                                                                            <div className="text-gray-400 break-words">
                                                                                                <strong className="text-gray-300">How it works:</strong> Each URL from the evidence is tested with an HTTP request to verify it's accessible. URLs returning status codes 200-399 are considered valid.
                                                                                            </div>
                                                                                            <div className="text-gray-400 mt-2 break-words">
                                                                                                <strong className="text-gray-300">Success criteria:</strong> At least 50% of checked URLs must be accessible.
                                                                                            </div>
                                                                                            {check.evidence && check.evidence.length > 0 && (
                                                                                                <>
                                                                                                    <div className="text-gray-400 mt-2">
                                                                                                        <strong className="text-gray-300">Results:</strong>
                                                                                                    </div>
                                                                                                    <div className="space-y-1.5 ml-2">
                                                                                                        {check.evidence.map((urlCheck, idx) => (
                                                                                                            <div key={idx} className={`${urlCheck.exists ? 'text-green-400' : 'text-red-400'} break-all`}>
                                                                                                                {urlCheck.exists ? '‚úì' : '‚úó'} {urlCheck.url}
                                                                                                                {urlCheck.error && <div className="ml-4 text-[10px] text-gray-500 break-words">Error: {urlCheck.error}</div>}
                                                                                                            </div>
                                                                                                        ))}
                                                                                                    </div>
                                                                                                </>
                                                                                            )}
                                                                                        </>
                                                                                    )}
                                                                                    {check.name === 'Quote Exact Match' && (
                                                                                        <>
                                                                                            <div className="text-gray-400 break-words">
                                                                                                <strong className="text-gray-300">How it works:</strong> Extracts all quoted text from the claim (text within quotation marks) and searches for exact matches in the evidence snippets. This ensures direct quotes are accurately sourced.
                                                                                            </div>
                                                                                            <div className="text-gray-400 mt-2 break-words">
                                                                                                <strong className="text-gray-300">Success criteria:</strong> All quoted text must be found exactly in the evidence sources.
                                                                                            </div>
                                                                                            {check.evidence && check.evidence.length > 0 && (
                                                                                                <>
                                                                                                    <div className="text-gray-400 mt-2">
                                                                                                        <strong className="text-gray-300">Results:</strong>
                                                                                                    </div>
                                                                                                    <div className="space-y-1 ml-2">
                                                                                                        {check.evidence.map((quote, idx) => (
                                                                                                            <div key={idx} className={`${quote.found ? 'text-green-400' : 'text-red-400'} break-words`}>
                                                                                                                {quote.found ? '‚úì' : '‚úó'} "{quote.quote}"
                                                                                                            </div>
                                                                                                        ))}
                                                                                                    </div>
                                                                                                </>
                                                                                            )}
                                                                                        </>
                                                                                    )}
                                                                                    {check.name === 'Entity Consistency' && (
                                                                                        <>
                                                                                            <div className="text-gray-400 break-words">
                                                                                                <strong className="text-gray-300">How it works:</strong> Uses natural language processing (NLP) to identify named entities (people, places, organizations) in the claim, then checks how many evidence sources mention each entity. Multiple sources mentioning the same entity increases confidence.
                                                                                            </div>
                                                                                            <div className="text-gray-400 mt-2 break-words">
                                                                                                <strong className="text-gray-300">Success criteria:</strong> At least 50% of named entities must appear in 2 or more sources.
                                                                                            </div>
                                                                                            {check.evidence && check.evidence.length > 0 && (
                                                                                                <>
                                                                                                    <div className="text-gray-400 mt-2">
                                                                                                        <strong className="text-gray-300">Results:</strong>
                                                                                                    </div>
                                                                                                    <div className="space-y-1 ml-2">
                                                                                                        {check.evidence.map((entity, idx) => (
                                                                                                            <div key={idx} className={`${entity.sourcesMentioning >= 2 ? 'text-green-400' : 'text-red-400'} break-words`}>
                                                                                                                {entity.sourcesMentioning >= 2 ? '‚úì' : '‚úó'} {entity.entity} (found in {entity.sourcesMentioning}/{entity.totalSources} sources)
                                                                                                            </div>
                                                                                                        ))}
                                                                                                    </div>
                                                                                                </>
                                                                                            )}
                                                                                        </>
                                                                                    )}
                                                                                    {check.name === 'Source Credibility' && (
                                                                                        <>
                                                                                            <div className="text-gray-400 break-words">
                                                                                                <strong className="text-gray-300">How it works:</strong> Assigns credibility scores to source domains based on reputation. Academic (.edu), government (.gov), and established news/reference sites score higher. The scores are averaged across all sources.
                                                                                            </div>
                                                                                            <div className="text-gray-400 mt-2 break-words">
                                                                                                <strong className="text-gray-300">Scoring tiers:</strong>
                                                                                            </div>
                                                                                            <div className="ml-2 mt-1 space-y-1.5 text-gray-400">
                                                                                                <div>
                                                                                                    <span className="text-green-400 font-medium">High (90):</span>{' '}
                                                                                                    Wikipedia, .edu, .gov, Nature, Science, BBC, Reuters, AP News, PBS, arXiv, Britannica, NIH, CDC
                                                                                                </div>
                                                                                                <div>
                                                                                                    <span className="text-yellow-400 font-medium">Medium (70):</span>{' '}
                                                                                                    NYT, Forbes, Bloomberg, WSJ, The Guardian, Washington Post, CNN
                                                                                                </div>
                                                                                                <div>
                                                                                                    <span className="text-orange-400 font-medium">Low (40):</span>{' '}
                                                                                                    Medium, Blogspot, WordPress, Tumblr
                                                                                                </div>
                                                                                                <div>
                                                                                                    <span className="text-gray-500 font-medium">Unknown (60):</span>{' '}
                                                                                                    All other domains
                                                                                                </div>
                                                                                            </div>
                                                                                            <div className="text-gray-400 mt-2 break-words">
                                                                                                <strong className="text-gray-300">Success criteria:</strong> Average credibility score must be ‚â•60/100.
                                                                                            </div>
                                                                                            {check.evidence && check.evidence.length > 0 && (
                                                                                                <>
                                                                                                    <div className="text-gray-400 mt-2">
                                                                                                        <strong className="text-gray-300">Results:</strong>
                                                                                                    </div>
                                                                                                    <div className="space-y-1 ml-2">
                                                                                                        {check.evidence.map((source, idx) => (
                                                                                                            <div key={idx} className={`${source.score >= 60 ? 'text-green-400' : 'text-yellow-400'} break-all`}>
                                                                                                                {source.domain}: {source.score}/100
                                                                                                            </div>
                                                                                                        ))}
                                                                                                    </div>
                                                                                                </>
                                                                                            )}
                                                                                        </>
                                                                                    )}
                                                                                    {check.name === 'Temporal Consistency' && (
                                                                                        <>
                                                                                            <div className="text-gray-400 break-words">
                                                                                                <strong className="text-gray-300">How it works:</strong> Extracts dates and years from the claim using pattern matching (formats like "2024", "Jan 1, 2024", "1/1/2024"), then searches for these dates in the evidence sources to confirm temporal accuracy.
                                                                                            </div>
                                                                                            <div className="text-gray-400 mt-2 break-words">
                                                                                                <strong className="text-gray-300">Success criteria:</strong> At least 50% of dates/years must be confirmed in at least one source.
                                                                                            </div>
                                                                                            {check.evidence && check.evidence.length > 0 && (
                                                                                                <>
                                                                                                    <div className="text-gray-400 mt-2">
                                                                                                        <strong className="text-gray-300">Results:</strong>
                                                                                                    </div>
                                                                                                    <div className="space-y-1 ml-2">
                                                                                                        {check.evidence.map((dateCheck, idx) => (
                                                                                                            <div key={idx} className={`${dateCheck.sourcesConfirming > 0 ? 'text-green-400' : 'text-red-400'} break-words`}>
                                                                                                                {dateCheck.sourcesConfirming > 0 ? '‚úì' : '‚úó'} {dateCheck.date} (confirmed in {dateCheck.sourcesConfirming}/{dateCheck.totalSources} sources)
                                                                                                            </div>
                                                                                                        ))}
                                                                                                    </div>
                                                                                                </>
                                                                                            )}
                                                                                        </>
                                                                                    )}
                                                                                </div>
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                </div>
                                                            </div>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}

                                            {verification.evidence?.length > 0 && (
                                                <div>
                                                    <h3 className="text-sm font-semibold mb-3 text-gray-200">
                                                        Evidence ({verification.evidence.length} sources):
                                                    </h3>
                                                    <div className="space-y-3">
                                                        {verification.evidence.map((source, i) => (
                                                            <div key={i} className="p-3 bg-[#2D2D2D] border border-[#404040] rounded-lg">
                                                                <div className="font-medium text-sm mb-1 text-gray-100">{source.title}</div>
                                                                <div className="text-xs text-gray-300 mb-2 line-clamp-3">{source.snippet}</div>
                                                                <a href={source.url} target="_blank" className="text-xs text-[#CC785C] hover:underline break-all">
                                                                    {source.url}
                                                                </a>
                                                            </div>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}

                                            {verification.fraudProof && (
                                                <div className="mt-4 p-3 bg-red-950/30 border-2 border-red-800 rounded-lg">
                                                    <h3 className="text-sm font-semibold mb-2 text-red-400 flex items-center gap-2">
                                                        üö® Fraud Proof Generated
                                                    </h3>
                                                    <div className="space-y-2 text-xs">
                                                        <div>
                                                            <span className="text-gray-400">Failed Check:</span>
                                                            <span className="ml-2 text-red-300 font-medium">{verification.fraudProof.failedCheck}</span>
                                                        </div>
                                                        <div>
                                                            <span className="text-gray-400">Reason:</span>
                                                            <div className="ml-2 mt-1 text-red-300">{verification.fraudProof.reason}</div>
                                                        </div>
                                                        {verification.fraudProof.proofHash && (
                                                            <div>
                                                                <span className="text-gray-400">Proof Hash:</span>
                                                                <div className="ml-2 mt-1 font-mono text-[10px] text-red-400 break-all">
                                                                    {verification.fraudProof.proofHash}
                                                                </div>
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                            )}

                                            <div className="mt-4 p-3 bg-[#CC785C]/10 border border-[#CC785C]/30 rounded-lg">
                                                <div className="text-xs text-gray-200">
                                                    <strong className="text-[#CC785C]">üí° Fraud Proof System:</strong> Claims are verified against external sources using deterministic checks. Anyone can independently verify these results.
                                                </div>
                                            </div>
                                        </>
                                    )}
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Mobile bottom navigation */}
                    <div className="md:hidden fixed bottom-0 left-0 right-0 z-50 bg-[#1A1A1A] border-t border-[#2D2D2D] flex">
                        <button
                            onClick={() => { setMobileActiveTab('fraud'); setSidePanelOpen(false); }}
                            className={`flex-1 flex flex-col items-center py-3 px-2 text-xs transition-colors ${
                                mobileActiveTab === 'fraud'
                                    ? 'text-[#CC785C]'
                                    : 'text-gray-500'
                            }`}
                        >
                            <svg className="w-5 h-5 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                            </svg>
                            Fraud Proof
                        </button>
                        <button
                            onClick={() => { setMobileActiveTab('chat'); setSidePanelOpen(false); }}
                            className={`flex-1 flex flex-col items-center py-3 px-2 text-xs transition-colors ${
                                mobileActiveTab === 'chat'
                                    ? 'text-[#CC785C]'
                                    : 'text-gray-500'
                            }`}
                        >
                            <svg className="w-5 h-5 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                            </svg>
                            Chat
                        </button>
                    </div>

                    {merkleModalOpen && merkleProofHashes && (
                        <MerkleProofModal
                            claimText={selectedClaim?.text}
                            merkleIndex={selectedClaim?.merkleIndex}
                            proofData={merkleProofHashes}
                            commitment={currentCommitment}
                            onClose={() => setMerkleModalOpen(false)}
                        />
                    )}

                    {whyModalOpen && ReactDOM.createPortal(
                        <div className="fixed inset-0 z-[9999] flex items-center justify-center" onClick={() => setWhyModalOpen(false)}>
                            <div className="absolute inset-0 bg-black/70 backdrop-blur-sm" />
                            <div
                                className="relative z-10 w-full max-w-[480px] mx-4 max-h-[90vh] overflow-y-auto bg-[#1E1E1E] border border-[#3D3D3D] rounded-xl shadow-2xl overflow-hidden"
                                onClick={e => e.stopPropagation()}
                            >
                                <div className="flex items-center justify-between p-4 border-b border-[#2D2D2D]">
                                    <h3 className="text-sm font-bold text-gray-100">Why I built this</h3>
                                    <button onClick={() => setWhyModalOpen(false)} className="text-gray-400 hover:text-gray-200 transition">
                                        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                        </svg>
                                    </button>
                                </div>
                                <div className="p-5 text-sm text-gray-300 leading-relaxed space-y-3">
                                    <p>AI models hallucinate. They make things up and say them with complete confidence. If you trust the wrong answer, that's not just an AI problem ‚Äî it's your problem. Bad information leads to bad decisions.</p>
                                    <p>Blockchains solved a version of this already. They created systems where you don't have to trust anyone ‚Äî you can just verify. Every transaction is provable, every record is permanent.</p>
                                    <p>I wanted to see if the same idea could work for AI. Can we take a model's output and make it verifiable? Can we catch lies with math instead of gut feeling?</p>
                                    <p>This is my experiment. Every claim the AI makes gets locked into a cryptographic commitment, checked against real sources, and proven with Merkle proofs. If it's wrong, there's a receipt.</p>
                                    <p className="text-gray-500 text-xs italic">Built by Val Yermakova, painstakingly vibe-coded with Claude.</p>
                                </div>
                            </div>
                        </div>,
                        document.body
                    )}
                </div>
            );
        };

        ReactDOM.render(<VerifiableClaudeDemo />, document.getElementById('root'));
    </script>
</body>
</html>